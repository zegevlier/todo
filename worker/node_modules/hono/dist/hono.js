"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hono = void 0;
const compose_1 = require("./compose");
const context_1 = require("./context");
const router_1 = require("./router");
const trie_router_1 = require("./router/trie-router"); // Default Router
const url_1 = require("./utils/url");
const methods = ['get', 'post', 'put', 'delete', 'head', 'options', 'patch'];
function defineDynamicClass() {
    return class {
    };
}
class Hono extends defineDynamicClass() {
    constructor(init = {}) {
        super();
        this.router = new trie_router_1.TrieRouter();
        this.strict = true; // strict routing - default is true
        this._tempPath = '';
        this.path = '/';
        this.routes = [];
        this.notFoundHandler = (c) => {
            const message = '404 Not Found';
            return c.text(message, 404);
        };
        this.errorHandler = (err, c) => {
            console.error(`${err.stack || err.message}`);
            const message = 'Internal Server Error';
            return c.text(message, 500);
        };
        const allMethods = [...methods, router_1.METHOD_NAME_ALL_LOWERCASE];
        allMethods.map((method) => {
            this[method] = (args1, ...args) => {
                if (typeof args1 === 'string') {
                    this.path = args1;
                }
                else {
                    this.addRoute(method, this.path, args1);
                }
                args.map((handler) => {
                    if (typeof handler !== 'string') {
                        this.addRoute(method, this.path, handler);
                    }
                });
                return this;
            };
        });
        Object.assign(this, init);
    }
    route(path, app) {
        this._tempPath = path;
        if (app) {
            app.routes.map((r) => {
                this.addRoute(r.method, r.path, r.handler);
            });
            this._tempPath = '';
        }
        return this;
    }
    use(arg1, ...handlers) {
        if (typeof arg1 === 'string') {
            this.path = arg1;
        }
        else {
            handlers.unshift(arg1);
        }
        handlers.map((handler) => {
            this.addRoute(router_1.METHOD_NAME_ALL, this.path, handler);
        });
        return this;
    }
    onError(handler) {
        this.errorHandler = handler;
        return this;
    }
    notFound(handler) {
        this.notFoundHandler = handler;
        return this;
    }
    addRoute(method, path, handler) {
        method = method.toUpperCase();
        if (this._tempPath) {
            path = (0, url_1.mergePath)(this._tempPath, path);
        }
        this.router.add(method, path, handler);
        const r = { path: path, method: method, handler: handler };
        this.routes.push(r);
    }
    async matchRoute(method, path) {
        return this.router.match(method, path);
    }
    async dispatch(request, event, env) {
        const path = (0, url_1.getPathFromURL)(request.url, { strict: this.strict });
        const method = request.method;
        const result = await this.matchRoute(method, path);
        request.param = ((key) => {
            if (result) {
                if (key) {
                    return result.params[key];
                }
                else {
                    return result.params;
                }
            }
            return null;
        });
        const handlers = result ? result.handlers : [this.notFoundHandler];
        const c = new context_1.Context(request, {
            env: env,
            event: event,
        });
        c.notFound = () => this.notFoundHandler(c);
        const composed = (0, compose_1.compose)(handlers, this.errorHandler, this.notFoundHandler);
        let context;
        try {
            context = await composed(c);
        }
        catch (err) {
            if (err instanceof Error) {
                return this.errorHandler(err, c);
            }
            throw err;
        }
        if (!context.res)
            return context.notFound();
        return context.res;
    }
    async handleEvent(event) {
        return this.dispatch(event.request, event);
    }
    async fetch(request, env, event) {
        return this.dispatch(request, event, env);
    }
    request(input, requestInit) {
        const req = input instanceof Request ? input : new Request(input, requestInit);
        return this.dispatch(req);
    }
    fire() {
        addEventListener('fetch', (event) => {
            event.respondWith(this.handleEvent(event));
        });
    }
}
exports.Hono = Hono;
