"use strict";
// Based on the code in the `express-graphql` package.
// https://github.com/graphql/express-graphql/blob/main/src/index.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorMessages = exports.getGraphQLParams = exports.graphqlServer = void 0;
const graphql_1 = require("graphql");
const parse_body_1 = require("./parse-body");
const graphqlServer = (options) => {
    var _a, _b;
    const schema = options.schema;
    const rootValue = options.rootValue;
    const pretty = (_a = options.pretty) !== null && _a !== void 0 ? _a : false;
    const validationRules = (_b = options.validationRules) !== null && _b !== void 0 ? _b : [];
    // const showGraphiQL = options.graphiql ?? false
    return async (c, next) => {
        // GraphQL HTTP only supports GET and POST methods.
        if (c.req.method !== 'GET' && c.req.method !== 'POST') {
            return c.json((0, exports.errorMessages)(['GraphQL only supports GET and POST requests.']), 405, {
                Allow: 'GET, POST',
            });
        }
        let params;
        try {
            params = await (0, exports.getGraphQLParams)(c.req);
        }
        catch (e) {
            if (e instanceof Error) {
                console.error(`${e.stack || e.message}`);
                return c.json((0, exports.errorMessages)([e.message], [e]), 400);
            }
            throw e;
        }
        const { query, variables, operationName } = params;
        if (query == null) {
            return c.json((0, exports.errorMessages)(['Must provide query string.']), 400);
        }
        const schemaValidationErrors = (0, graphql_1.validateSchema)(schema);
        if (schemaValidationErrors.length > 0) {
            // Return 500: Internal Server Error if invalid schema.
            return c.json((0, exports.errorMessages)(['GraphQL schema validation error.'], schemaValidationErrors), 500);
        }
        let documentAST;
        try {
            documentAST = (0, graphql_1.parse)(new graphql_1.Source(query, 'GraphQL request'));
        }
        catch (syntaxError) {
            // Return 400: Bad Request if any syntax errors errors exist.
            if (syntaxError instanceof Error) {
                console.error(`${syntaxError.stack || syntaxError.message}`);
                const e = new graphql_1.GraphQLError(syntaxError.message, {
                    originalError: syntaxError,
                });
                return c.json((0, exports.errorMessages)(['GraphQL syntax error.'], [e]), 400);
            }
            throw syntaxError;
        }
        // Validate AST, reporting any errors.
        const validationErrors = (0, graphql_1.validate)(schema, documentAST, [...graphql_1.specifiedRules, ...validationRules]);
        if (validationErrors.length > 0) {
            // Return 400: Bad Request if any validation errors exist.
            return c.json((0, exports.errorMessages)(['GraphQL validation error.'], validationErrors), 400);
        }
        if (c.req.method === 'GET') {
            // Determine if this GET request will perform a non-query.
            const operationAST = (0, graphql_1.getOperationAST)(documentAST, operationName);
            if (operationAST && operationAST.operation !== 'query') {
                /*
                Now , does not support GraphiQL
                if (showGraphiQL) {
                  //return respondWithGraphiQL(response, graphiqlOptions, params)
                }
                */
                // Otherwise, report a 405: Method Not Allowed error.
                return c.json((0, exports.errorMessages)([
                    `Can only perform a ${operationAST.operation} operation from a POST request.`,
                ]), 405, { Allow: 'POST' });
            }
        }
        let result;
        try {
            result = await (0, graphql_1.execute)({
                schema,
                document: documentAST,
                rootValue,
                variableValues: variables,
                operationName: operationName,
            });
        }
        catch (contextError) {
            if (contextError instanceof Error) {
                console.error(`${contextError.stack || contextError.message}`);
                const e = new graphql_1.GraphQLError(contextError.message, {
                    originalError: contextError,
                    nodes: documentAST,
                });
                // Return 400: Bad Request if any execution context errors exist.
                return c.json((0, exports.errorMessages)(['GraphQL execution context error.'], [e]), 400);
            }
            throw contextError;
        }
        if (!result.data) {
            if (result.errors) {
                return c.json((0, exports.errorMessages)([result.errors.toString()], result.errors), 500);
            }
        }
        /*
        Now, does not support GraphiQL
        if (showGraphiQL) {
        }
        */
        if (pretty) {
            const payload = JSON.stringify(result, null, pretty ? 2 : 0);
            return c.text(payload, 200, {
                'Content-Type': 'application/json',
            });
        }
        else {
            return c.json(result);
        }
        await next(); // XXX
    };
};
exports.graphqlServer = graphqlServer;
const getGraphQLParams = async (request) => {
    var _a, _b, _c;
    const urlData = new URLSearchParams(request.url.split('?')[1]);
    const bodyData = await (0, parse_body_1.parseBody)(request);
    // GraphQL Query string.
    let query = (_a = urlData.get('query')) !== null && _a !== void 0 ? _a : bodyData.query;
    if (typeof query !== 'string') {
        query = null;
    }
    // Parse the variables if needed.
    let variables = ((_b = urlData.get('variables')) !== null && _b !== void 0 ? _b : bodyData.variables);
    if (typeof variables === 'string') {
        try {
            variables = JSON.parse(variables);
        }
        catch (_d) {
            throw Error('Variables are invalid JSON.');
        }
    }
    else if (typeof variables !== 'object') {
        variables = null;
    }
    // Name of GraphQL operation to execute.
    let operationName = (_c = urlData.get('operationName')) !== null && _c !== void 0 ? _c : bodyData.operationName;
    if (typeof operationName !== 'string') {
        operationName = null;
    }
    const raw = urlData.get('raw') != null || bodyData.raw !== undefined;
    const params = {
        query: query,
        variables: variables,
        operationName: operationName,
        raw: raw,
    };
    return params;
};
exports.getGraphQLParams = getGraphQLParams;
const errorMessages = (messages, graphqlErrors) => {
    if (graphqlErrors) {
        return {
            errors: graphqlErrors,
        };
    }
    return {
        errors: messages.map((message) => {
            return {
                message: message,
            };
        }),
    };
};
exports.errorMessages = errorMessages;
// export const graphiQLResponse = () => {}
