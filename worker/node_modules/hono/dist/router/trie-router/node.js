"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = void 0;
const router_1 = require("../../router");
const url_1 = require("../../utils/url");
function findParam(node, name) {
    for (let i = 0, len = node.patterns.length; i < len; i++) {
        if (typeof node.patterns[i] === 'object' && node.patterns[i][1] === name) {
            return true;
        }
    }
    const nodes = Object.values(node.children);
    for (let i = 0, len = nodes.length; i < len; i++) {
        if (findParam(nodes[i], name)) {
            return true;
        }
    }
    return false;
}
class Node {
    constructor(method, handler, children) {
        this.order = 0;
        this.children = children || {};
        this.methods = [];
        if (method && handler) {
            const m = {};
            m[method] = { handler: handler, score: 0, name: this.name };
            this.methods = [m];
        }
        this.patterns = [];
    }
    insert(method, path, handler) {
        this.name = `${method} ${path}`;
        this.order = ++this.order;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let curNode = this;
        const parts = (0, url_1.splitPath)(path);
        const parentPatterns = [];
        const errorMessage = (name) => {
            return `Duplicate param name, use another name instead of '${name}' - ${method} ${path} <--- '${name}'`;
        };
        for (let i = 0, len = parts.length; i < len; i++) {
            const p = parts[i];
            if (Object.keys(curNode.children).includes(p)) {
                parentPatterns.push(...curNode.patterns);
                curNode = curNode.children[p];
                continue;
            }
            curNode.children[p] = new Node();
            const pattern = (0, url_1.getPattern)(p);
            if (pattern) {
                if (typeof pattern === 'object') {
                    for (let j = 0, len = parentPatterns.length; j < len; j++) {
                        if (typeof parentPatterns[j] === 'object' && parentPatterns[j][1] === pattern[1]) {
                            throw new Error(errorMessage(pattern[1]));
                        }
                    }
                    if (Object.values(curNode.children).some((n) => findParam(n, pattern[1]))) {
                        throw new Error(errorMessage(pattern[1]));
                    }
                }
                curNode.patterns.push(pattern);
                parentPatterns.push(...curNode.patterns);
            }
            parentPatterns.push(...curNode.patterns);
            curNode = curNode.children[p];
        }
        let score = 1;
        if (path === '*') {
            score = score + this.order * 0.01;
        }
        else {
            score = parts.length + this.order * 0.01;
        }
        if (!curNode.methods.length) {
            curNode.methods = [];
        }
        const m = {};
        const handlerSet = { handler: handler, name: this.name, score: score };
        m[method] = handlerSet;
        curNode.methods.push(m);
        return curNode;
    }
    getHandlerSets(node, method, wildcard) {
        const handlerSets = [];
        node.methods.map((m) => {
            const handlerSet = m[method] || m[router_1.METHOD_NAME_ALL];
            if (handlerSet !== undefined) {
                const hs = Object.assign({}, handlerSet);
                if (wildcard) {
                    hs.score = handlerSet.score - 1;
                }
                handlerSets.push(hs);
                return;
            }
        });
        return handlerSets;
    }
    next(node, part, method, isLast) {
        const handlerSets = [];
        const nextNodes = [];
        const params = {};
        for (let j = 0, len = node.patterns.length; j < len; j++) {
            const pattern = node.patterns[j];
            // Wildcard
            // '/hello/*/foo' => match /hello/bar/foo
            if (pattern === '*') {
                const astNode = node.children['*'];
                if (astNode) {
                    handlerSets.push(...this.getHandlerSets(astNode, method));
                    nextNodes.push(astNode);
                }
            }
            if (part === '')
                continue;
            // Named match
            // `/posts/:id` => match /posts/123
            const [key, name, matcher] = pattern;
            if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {
                if (typeof key === 'string') {
                    if (isLast === true) {
                        handlerSets.push(...this.getHandlerSets(node.children[key], method));
                    }
                    nextNodes.push(node.children[key]);
                }
                if (typeof name === 'string') {
                    params[name] = part;
                }
            }
        }
        const nextNode = node.children[part];
        if (nextNode) {
            if (isLast === true) {
                // '/hello/*' => match '/hello'
                if (nextNode.children['*']) {
                    handlerSets.push(...this.getHandlerSets(nextNode.children['*'], method, true));
                }
                handlerSets.push(...this.getHandlerSets(nextNode, method));
            }
            nextNodes.push(nextNode);
        }
        const next = {
            nodes: nextNodes,
            handlerSets: handlerSets,
            params: params,
        };
        return next;
    }
    search(method, path) {
        const handlerSets = [];
        let params = {};
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const curNode = this;
        let curNodes = [curNode];
        const parts = (0, url_1.splitPath)(path);
        for (let i = 0, len = parts.length; i < len; i++) {
            const p = parts[i];
            const isLast = i === len - 1;
            const tempNodes = [];
            for (let j = 0, len2 = curNodes.length; j < len2; j++) {
                const res = this.next(curNodes[j], p, method, isLast);
                if (res.nodes.length === 0) {
                    continue;
                }
                handlerSets.push(...res.handlerSets);
                params = Object.assign(params, res.params);
                tempNodes.push(...res.nodes);
            }
            curNodes = tempNodes;
        }
        if (handlerSets.length <= 0)
            return null;
        const handlers = handlerSets
            .sort((a, b) => {
            return a.score - b.score;
        })
            .map((s) => {
            return s.handler;
        });
        return { handlers, params };
    }
}
exports.Node = Node;
