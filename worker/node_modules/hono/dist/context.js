"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const response_1 = require("./response");
const url_1 = require("./utils/url");
class Context {
    constructor(req, opts = {
        env: {},
        event: undefined,
        res: undefined,
    }) {
        this._status = 200;
        this._pretty = false;
        this._prettySpace = 2;
        this.req = this.initRequest(req);
        this._map = {};
        Object.assign(this, opts);
        if (!this.res) {
            const res = new response_1.HonoResponse(null, { status: 404 });
            res._finalized = false;
            this.res = res;
        }
    }
    initRequest(req) {
        req.header = ((name) => {
            if (name) {
                return req.headers.get(name);
            }
            else {
                const result = {};
                for (const [key, value] of req.headers) {
                    result[key] = value;
                }
                return result;
            }
        });
        req.query = ((key) => {
            const url = new URL(req.url);
            if (key) {
                return url.searchParams.get(key);
            }
            else {
                const result = {};
                for (const key of url.searchParams.keys()) {
                    result[key] = url.searchParams.get(key) || '';
                }
                return result;
            }
        });
        req.queries = ((key) => {
            const url = new URL(req.url);
            if (key) {
                return url.searchParams.getAll(key);
            }
            else {
                const result = {};
                for (const key of url.searchParams.keys()) {
                    result[key] = url.searchParams.getAll(key);
                }
                return result;
            }
        });
        return req;
    }
    header(name, value) {
        this.res.headers.set(name, value);
    }
    status(status) {
        this._status = status;
    }
    set(key, value) {
        this._map[key] = value;
    }
    get(key) {
        return this._map[key];
    }
    pretty(prettyJSON, space = 2) {
        this._pretty = prettyJSON;
        this._prettySpace = space;
    }
    newResponse(data, init = {}) {
        init.status = init.status || this._status || 200;
        const headers = {};
        this.res.headers.forEach((v, k) => {
            headers[k] = v;
        });
        init.headers = Object.assign(headers, init.headers);
        return new Response(data, init);
    }
    body(data, status = this._status, headers = {}) {
        return this.newResponse(data, {
            status: status,
            headers: headers,
        });
    }
    text(text, status = this._status, headers = {}) {
        if (typeof text !== 'string') {
            throw new TypeError('text method arg must be a string!');
        }
        headers['Content-Type'] || (headers['Content-Type'] = 'text/plain; charset=UTF-8');
        return this.body(text, status, headers);
    }
    json(object, status = this._status, headers = {}) {
        if (typeof object !== 'object') {
            throw new TypeError('json method arg must be an object!');
        }
        const body = this._pretty
            ? JSON.stringify(object, null, this._prettySpace)
            : JSON.stringify(object);
        headers['Content-Type'] || (headers['Content-Type'] = 'application/json; charset=UTF-8');
        return this.body(body, status, headers);
    }
    html(html, status = this._status, headers = {}) {
        if (typeof html !== 'string') {
            throw new TypeError('html method arg must be a string!');
        }
        headers['Content-Type'] || (headers['Content-Type'] = 'text/html; charset=UTF-8');
        return this.body(html, status, headers);
    }
    redirect(location, status = 302) {
        if (typeof location !== 'string') {
            throw new TypeError('location must be a string!');
        }
        if (!(0, url_1.isAbsoluteURL)(location)) {
            const url = new URL(this.req.url);
            url.pathname = location;
            location = url.toString();
        }
        return this.newResponse(null, {
            status: status,
            headers: {
                Location: location,
            },
        });
    }
}
exports.Context = Context;
